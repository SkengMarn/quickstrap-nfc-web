var o=Object.defineProperty;var i=(n,t,e)=>t in n?o(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var r=(n,t,e)=>i(n,typeof t!="symbol"?t+"":t,e);class l{constructor(){r(this,"attempts",new Map);r(this,"cleanupInterval");this.cleanupInterval=setInterval(()=>{this.cleanup()},5*60*1e3)}isAllowed(t,e){const s=Date.now(),a=this.attempts.get(t);return a?a.blocked&&a.blockExpiry&&s<a.blockExpiry?!1:s-a.firstAttempt>e.windowMs?(this.attempts.set(t,{attempts:1,firstAttempt:s,lastAttempt:s,blocked:!1}),!0):a.attempts>=e.maxAttempts?(this.attempts.set(t,{...a,blocked:!0,blockExpiry:s+e.blockDurationMs}),!1):(this.attempts.set(t,{...a,attempts:a.attempts+1,lastAttempt:s}),!0):(this.attempts.set(t,{attempts:1,firstAttempt:s,lastAttempt:s,blocked:!1}),!0)}getRemainingAttempts(t,e){const s=this.attempts.get(t);return!s||Date.now()-s.firstAttempt>e.windowMs?e.maxAttempts:Math.max(0,e.maxAttempts-s.attempts)}getTimeUntilUnblocked(t){const e=this.attempts.get(t);if(!e||!e.blocked||!e.blockExpiry)return 0;const s=Date.now();return Math.max(0,e.blockExpiry-s)}reset(t){this.attempts.delete(t)}cleanup(){const t=Date.now(),e=24*60*60*1e3;for(const[s,a]of this.attempts.entries()){if(t-a.lastAttempt>e){this.attempts.delete(s);continue}a.blocked&&a.blockExpiry&&t>a.blockExpiry&&this.attempts.delete(s)}}getStats(){let t=0;const e=Date.now();for(const s of this.attempts.values())s.blocked&&s.blockExpiry&&e<s.blockExpiry&&t++;return{totalIdentifiers:this.attempts.size,blockedIdentifiers:t}}destroy(){this.cleanupInterval&&clearInterval(this.cleanupInterval),this.attempts.clear()}}const m=new l,c={login:{maxAttempts:5,windowMs:15*60*1e3,blockDurationMs:30*60*1e3},api:{maxAttempts:100,windowMs:60*1e3,blockDurationMs:5*60*1e3},telegram:{maxAttempts:10,windowMs:60*1e3,blockDurationMs:10*60*1e3}};export{m as default,c as rateLimitConfigs,m as rateLimiter};
//# sourceMappingURL=rateLimiter-RDTGfPPa.js.map
